> [Главная](../index.md) / [Injetion](index.md) / Shell injection

### <a id="about"></a> [Что такое Shell Injection.](#about)

Shell инъекция - внедрение shell кода в shell запрос. Позволяет выполнять произвольные команды не веб сервере.

###  <a id="example"></a> [Пример уязвимости Shell Injection.](#example)

Предположим есть веб сайт на котором можно пропинговать произвольный ресурс. Для выполнения пинга отправляется GET запрос на url `site.hach/ping/?host=ya.ru`. Предположим что сервер выполняет пинг при помощи кода ниже

```php
$host    = $_GET['host'];
$command = "ping '$host'";
$ping    = exec($command);

echo join('\n', $ping);
```

Проблема заключается в том, что нет никакой проверки получаемых данных, и злоумышленник может выполнить на сервере произвольную команду просто изменив запрос на `site.hach/ping/?host=ya.ru'; rm -rf /*'`. Таким образом на сервере будет выполнена следующая команда

```bash    
ping 'ya.ru'; rm -rf /*''
```

И с сервера будет удалено абсолютна вся информация

### <a id="protection"></a> [Защита от Shell Injection.](#protection)

В PHP Есть замечательная функция [escapeshellcmd](http://php.net/manual/ru/function.escapeshellcmd.php) которая экранирует все метасимволы символы командной строки.

> Команда escapeshellcmd() экранирует любые символы в строке, которые могут быть использованы для обмана шелл-команд при выполнении произвольных команд. Эта функция должна быть использована для того, чтобы убедиться, что любые данные, вводимые пользователем, экранированы перед передачей их функции exec() или system(), или оператору "обратный апостроф".

Ниже представлен код который не допустит выполнения shell инъекции

```php
$host    = escapeshellcmd($_GET['host']);
$command = "ping '$host'";
$ping    = exec($command);

echo join('\n', $ping);
```

Таким образом при попытке выполнить инъекцию мы получится следующий Shell запрос
```bash  
ping 'ya.ru'\; rm -rf /* ''
```
Как видно, функция escapeshellcmd экранировала символ `;` что защитило нас от выполнения второй команды	