<!DOCTYPE html>
<html lang="en-us">

    <head>
        <meta charset="UTF-8">
        <title>SQL Injection - SQL инъекции | Security Notes by DmitryNaum</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" href="../stylesheets/normalize.css" media="screen">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" type="text/css" href="../stylesheets/stylesheet.css" media="screen">
        <link rel="stylesheet" type="text/css" href="../stylesheets/monokai_sublime.css" media="screen">
    </head>

    <body>
        <section class="page-header">
            <h1 class="project-name">Security Notes</h1>
            <h2 class="project-tagline">Заметки по безопасности web приложений</h2>
            <a href="https://github.com/DmitryNaum/securityNotes" class="btn">GitHub репозиторий</a>
            <a href="https://github.com/DmitryNaum/securityNotes/zipball/master" class="btn">.zip</a>
            <a href="https://github.com/DmitryNaum/securityNotes/tarball/master" class="btn">.tar.gz</a>
        </section>

        <section class="main-content">
            <ul class="breadcrumbs">
                <li><a href="../index.html">Главная</a></li>
                <li><a href="index.html">Injection</a></li>
                <li>SQL Injection</li>
            </ul>
            <h3>
                <a id="about" class="anchor" href="#about" aria-hidden="true"><span class="octicon octicon-link"></span></a>Что такое SQL Injection.
            </h3>

            <p>
                Внедрение SQL-кода (англ. SQL injection) — один из распространённых 
                способов взлома сайтов и программ, работающих с базами данных, 
                основанный на внедрении в запрос произвольного SQL-кода.
            </p>
            <p>
                Внедрение SQL, в зависимости от типа используемой СУБД и условий 
                внедрения, может дать возможность атакующему выполнить произвольный 
                запрос к базе данных (например, прочитать содержимое любых таблиц, 
                удалить, изменить или добавить данные), получить возможность чтения 
                и/или записи локальных файлов и выполнения произвольных команд на атакуемом сервере.
            </p>
            <p>
                Атака типа внедрения SQL может быть возможна из-за некорректной 
                обработки входных данных, используемых в SQL-запросах.
            </p>
            <p>
                При помощи SQL инъекций есть возможность "зомбировать" СУБД для коварных целей, 
                например сделать <a href="https://xakep.ru/2015/10/30/mysql-ddos/" target="_blank">частью ботнета</a>
            </p>

            <h3>
                <a id="vulnerability-example" class="anchor" href="#vulnerability-example" aria-hidden="true">
                    <span class="octicon octicon-link"></span></a>Пример уязвимости SQL Injection.
            </h3>
            <p>
                Предположим есть сайт на котором есть новостной раздел. 
                При просмотре новости мы попадаем на url вида <code>site.hach/news/?id=1</code>.
                Ниже представлен уязвимый кусок php кода который подгружает новость из БД.
            </p>
            <pre><code class="hljs php"><span class="hljs-variable">$id</span>  = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">'id'</span>];
<span class="hljs-variable">$sql</span> = <span class="hljs-string">"SELECT `id` FROM `news` WHERE `id` = '$id'"</span>;
</code></pre>
            <p>
                Таким образом, при запорсе страницы <code>site.hach/news/?id=1</code> в СУБД уйдет следующий запрос:
            </p>
            <pre><code class="hljs sql"><span class="hljs-operator"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">`id`</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">`news`</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">`id`</span> = <span class="hljs-string">'1'</span></span></code></pre>
            <p>
                Но стоит нам запростить страницу вида <code>site.hach/news/?id=1'; DELETE FROM `news` -- </code> 
                и наш запрос будет иметь следующий вид
            </p>
            <pre><code class="hljs sql"><span class="hljs-operator"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">`id`</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">`news`</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">`id`</span> = <span class="hljs-string">'1'</span>;</span> <span class="hljs-operator"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">`news`</span> <span class="hljs-comment">-- '</span></span></code></pre>

            <p>Таким образом в СУБД уйдет уже 2 запроса, и второй из них - DELETE который удалит все записи новостей</p>

            <h3>
                <a id="protection" class="anchor" href="#protection" aria-hidden="true">
                    <span class="octicon octicon-link"></span></a>Защита от SQL инъекций.
            </h3>
            <p>
                Проблема вышеприведенного PHP кода заключается в том, что данные полученные от пользователя никак не фильтруются.
                Все данные которые получаемые от пользователя необходимо в обязательном порядке валидировать и фильтровать!
            </p>
            <p>
                Самый простой и эффективный способ защитить вышеприведенного код от инъекции - преобразовать id новости в целое число.
                Но данный способ не является универсальным, т.к. будет работать только с числами.
            </p>

            <pre><code class="hljs php"><span class="hljs-variable">$id</span>  = intval(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">'id'</span>]);
<span class="hljs-variable">$sql</span> = <span class="hljs-string">"SELECT `id` FROM `news` WHERE `id` = '$id'"</span>;</code></pre>

            <p>
                Таким образом, при попытке внедрить SQL инъекцию все содержимое <code>$_GET['id']</code> 
                будет преобразовано в целое число и в базу уйдет нормальный запрос.
            </p>
            <pre><code class="hljs sql"><span class="hljs-operator"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">`id`</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">`news`</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">`id`</span> = <span class="hljs-string">'1'</span></span></code></pre>

            <p>
                Но как писалось выше, это не универсальный способ защитить приложение от SQL инъекций. 
                Это скорее костыль.
            </p>

            <p>
                Выделяют 2 способа защиты от SQL инъекций.<br>
                <a href="#escaping"><strong>Эскэйпинг параметров</strong></a> и 
                <a href="#parameterized"><strong>Параметризованные запросы</strong></a>
            </p>

            <h3>
                <a id="escaping" class="anchor" href="#escaping" aria-hidden="true">
                    <span class="octicon octicon-link"></span></a>Эскэйпинг параметров.
            </h3>
            <p>
                Эскейпинг - экранирование специальных символов в строке для предотвращения разрыва SQL запроса
                Далее будет описан пример использования эскейпинга параметров при использовании модуля PHP - mysqli.
                В mysqli как и во многих других модулях для работы с БД есть методы эскейпинга.
                Например <code>real_escape_string</code>.
                Ниже приведен пример использования <code>real_escape_string</code>. 
            </p>
            <pre><code class="hljs php"><span class="hljs-variable">$id</span>  = <span class="hljs-variable">$mysqli</span>-&gt;real_escape_string(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">'id'</span>]);
<span class="hljs-variable">$sql</span> = <span class="hljs-string">"select * from news where id = '{$id}';"</span>;</code></pre>

            <p>
                Таким образом наш SQL код, который уйдет в СУБД будет выглядеть следующим образом
            </p>
            <pre><code class="hljs sql"><span class="hljs-operator"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">`id`</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">`news`</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">`id`</span> = <span class="hljs-string">'1\'; drop table news -- '</span>;</span></code></pre>
            <p>
                Можно заметить что метод <code>real_escape_string</code> экранировал одинарную кавычку которая
                ранее разрывала наш запрос и делила его на 2 запорса. 
                В данном случае мы не найдем новость, но это не страшно т.к. 
                злоумышленник знал на что идет, но не получил ожидаемого.
            </p>
            
            <h3>
                <a id="parameterized" class="anchor" href="#parameterized" aria-hidden="true">
                    <span class="octicon octicon-link"></span></a>Параметризованные (подготавливаемые) запросы.
            </h3>
            <p>
                Этот способ, пожалуй, является самым правильным.<br>
                Выполнение параметризованного запроса проводится в два этапа: подготовка и исполнение. 
                На этапе подготовки на сервер посылается шаблон запроса. 
                Сервер выполняет синтаксическую проверку этого шаблона, строит план выполнения запроса и выделяет под него ресурсы.
            </p>
            <p>
                За подготовкой идет выполнение. 
                Во время запуска запроса клиент привязывает к псевдопеременным реальные значения и посылает их на сервер. 
                Сервер, в свою очередь, подставляет их в шаблон и запускает уже готовый запрос на выполнение.
            </p>
            <p>
                Параметризованный запрос можно запускать многократно. 
                Перед каждым запуском значения привязанных переменных будут передаваться на сервер и подставляться в текст запроса. 
                Сам текст запроса повторно не анализируется, равно как и не отсылается повторно шаблон.
            </p>
            
            <p>
                Ниже приведены 2 примера параметризованного запроса с использованием PDO
            </p>
                
            <pre><code class="hljs php"><span class="hljs-variable">$sql</span> = <span class="hljs-string">"SELECT `id` FROM `news` WHERE `id` = ?"</span>;
<span class="hljs-variable">$stm</span> = <span class="hljs-variable">$pdo</span>-&gt;prepare(sql);
<span class="hljs-variable">$id</span>  = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">'id'</span>];

<span class="hljs-variable">$stm</span>-&gt;execute([<span class="hljs-variable">$id</span>]);
<span class="hljs-variable">$result</span> = <span class="hljs-variable">$stm</span>-&gt;fetchAll();</code></pre>

<pre><code class="hljs php"><span class="hljs-variable">$sql</span> = <span class="hljs-string">"SELECT `id` FROM `news` WHERE `id` = :id"</span>;
<span class="hljs-variable">$stm</span> = <span class="hljs-variable">$pdo</span>-&gt;prepare(sql);
<span class="hljs-variable">$id</span>  = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">'id'</span>];

<span class="hljs-variable">$stm</span>-&gt;execute([<span class="hljs-string">':id'</span> =&gt; <span class="hljs-variable">$id</span>]);
<span class="hljs-variable">$result</span> = <span class="hljs-variable">$stm</span>-&gt;fetchAll();</code></pre>

            <footer class="site-footer">
                <span class="site-footer-owner"><a href="https://github.com/DmitryNaum/securityNotes">Security Notes</a> is maintained by <a href="https://github.com/DmitryNaum">DmitryNaum</a>.</span>

                <span class="site-footer-credits">Using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
            </footer>

        </section>


    </body>

</html>